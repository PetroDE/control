#!/usr/bin/env python3

# PetroDE Control script
#   It does stuff(TM)
#
# A script to build Docker images, compile code, run tests, be friendly to
# developers, enable local development, check in build configuration next to
# code, kiss babies, and be popular.
#
# We really don't expect much of it. /s
#
# Exit codes:
# 1 - Control operation failed, check output
# 2 - Something failed early (Docker daemon not started, malformed Controlfile)
# 3 - Operation pre-check failed

# Things that are needed:
#   - Add handling for --pull --no-pull and default behavior
#   - Clearly defined global options when ./control is run
#   - Clearly defined options when ./control build is run
#   - Override global defaults with Controlfile
#   - Override Controlfile settings with CLI arguments
#
# TODO: handle ^C without printing a stack trace, like normal people MOM!

import argparse
#import configparser
import base64
import docker
import json
import os
import re
import requests
import sys

def err(arg):
    log(arg, level='error')

def log(arg, level='info'):
    if (level == 'info' or
            level == 'error' or
            (level == 'warn' and options.debug) or
            (level == 'debug' and options.debug)):
        print('[{LEVEL:5s}] {ARG}'.format(LEVEL=level.upper(), ARG=arg), file=sys.stderr)

class Registry:
    def __init__(self, domain, port=None):
        self.domain = domain
        self.port = port
        if port:
            self.endpoint = '{}:{}'.format(self.domain, self.port)
        else:
            self.endpoint = self.domain
        # TODO support insecure registries and V1 registries
        self.baseuri = 'https://{}/v2'.format(self.endpoint)
        certdir = '/etc/docker/certs.d/{reg}'.format(reg=self.endpoint)
        self.certfile = None
        self.session = requests.Session()
        if os.path.isfile(os.path.expanduser('~/.docker/config.json')):
            with open(os.path.expanduser('~/.docker/config.json')) as f:
                try:
                    j = json.load(f)
                    self.session.auth = tuple(base64.b64decode(
                            j['auths']['https://{}'.format(self.endpoint)]['auth']
                            ).decode('utf-8').split(':'))
                    log('setting basicauth', level='debug')
                except json.decoder.JSONDecodeError as e:
                    log('Docker config file not valid JSON: {}'.format(str(e)), level='warn')
                except KeyError:
                    pass
        if os.path.isdir(certdir):
            for certfile in map(lambda x: '{}/{}'.format(certdir, x), os.listdir(certdir)):
                try:
                    r = self.session.get(
                            'https://{}/v0'.format(self.endpoint),
                            verify=certfile)
                except requests.exceptions.SSLError as e:
                    log('Cert file rejected {}'.format(certfile), level='debug')
                    continue
                log('Setting verify', level='debug')
                self.certfile = certfile
                break
        r = self.get('https://{}/v0'.format(self.endpoint))
        if r.status_code == 401:
            print('You are not logged into registry {}\nRun docker login'.format(self.endpoint))
            if options.pull:
                exit(3)

    def get(self, uri):
        if self.certfile:
            return self.session.get(uri, verify=self.certfile)
        return self.session.get(uri)

    def get_id_of_repo(self, repo):
        r = self.get('{base}/{image}/manifests/{tag}'.format(base=self.baseuri,
            image=repo.image,
            tag=repo.tag))
        if r.status_code == 200:
            log(r.text)
        else:
            log(r.status_code)
            log(r.text)

class Repository:
    #This matches more than is valid, but not less than is valid. Notably,
    #    * Slash in the registry portion
    #    * Adjacent periods are accepted
    #But, you had an invalid repo name if you hit either of those.
    matcher = re.compile(r'(?:'
            r'(?P<domain>localhost|(?:[-_\w]+\.[-_\w]+)+|[-_\w]+(?=:))'
            r'(?::(?P<port>\d{1,5}))?'
            r'/)?'
            r'(?P<image>[-_./\w]+)'
            r'(?::(?P<tag>[-_.\w]+))?')

    def __init__(self, image, tag='latest', domain=None, port=None):
        self.domain = domain
        self.port = port
        self.image = image
        self.tag = tag
        if domain and port:
            self.registry = '{}:{}'.format(self.domain, self.port)
            self.repo = '{}:{}/{}:{}'.format(self.domain,
                    self.port,
                    self.image,
                    self.port)
        elif domain:
            self.registry = '{}'.format(self.domain)
            self.repo = '{}/{}:{}'.format(self.domain,
                    self.image,
                    self.port)
        else:
            self.registry = False
            self.repo = '{}:{}'.format(self.image, self.port)

    @classmethod
    def match(cls, text):
        m = Repository.matcher.search(text)
        return Repository(domain=m.group('domain'),
                port=m.group('port'),
                image=m.group('image'),
                tag=m.group('tag'))

# TODO: finish
def image_is_newer(base):
    log('is_image_newer', level='debug')
    if base.image == 'scratch':
        err('Control does not handle building FROM scratch yet')
        exit(1)
    elif not base.registry:
        return True #Giving up on any kind of intelligence in dealing with the Hub.

    log('Contacting registry at {}'.format(base.registry), level='debug')
    reg = Registry(base.domain, base.port)
    reg.get_id_of_repo(base)
    #TODO: Need to log into registries
    #try:
    #    if os.path.isdir('/etc/docker/certs.d/{}'.format(base.registry)):
    #        r = requests.get(
    #                'https://{registry}/v2/{image}/manifests/{tag}'.format(registry=base.registry,
    #                    image=base.image,
    #                    tag=base.tag),
    #                verify='/etc/docker/certs.d/{registry}/ca.crt'.format(registry=base.registry))
    #    else:
    #        log('road less taken', level='debug')
    #        r = requests.get(
    #                'https://{registry}/v2/{image}/manifests/{tag}'.format(registry=base.registry,
    #                    image=base.image,
    #                    tag=base.tag))
    #    log(r.json())
    #except requests.exceptions.SSLError as e:
    #    err(e)
    exit(-1)

def pulling(repo):
    """We make use of the difference between None and False, so explicit
    checking against False or True is necessary."""
    if options.pull == False:
        return False
    elif options.func.__name__ == 'build' and not repo.registry and not options.pull:
        return False
    return True

def print_formatted(line):
    if options.debug:
        print('bytes: {}'.format(line))
    if len(line) == 1:
        print(list(line.values())[0].strip())
        return
    if 'error' in line.keys():
        print('\x1b[31m{}\x1b[0m'.format(line['error']))
    if 'id' in line.keys() and (not 'progressDetail' in line.keys() or not line['progressDetail']):
        print('{}: {}'.format(line['id'], line['status']))
        return

# TODO: DRY it up
def build(args):
    if args.debug or args.dry_run:
        print('running docker build')
    if not hasattr(args, 'image') or not args.image:
        err('No image name was specified. Edit your Controlfile or specify with -i')
        exit(3)
    if os.path.isfile(args.dockerfile):
        with open(args.dockerfile, 'r') as f:
            for line in f:
                if line.startswith('FROM'):
                    upstream = Repository.match(line.split()[1])
                    break
    else:
        err('Dockerfile does not exist')
        exit(3)
    if pulling(upstream) and image_is_newer(upstream):
        pass
    if not args.dry_run:
        for line in (json.loads(l.decode('utf-8').strip()) for l in docker.build(path='.',
                tag=args.image,
                nocache=args.no_cache,
                rm=args.no_rm,
                dockerfile=args.dockerfile)):
            print_formatted(line)
            if 'error' in line.keys():
                return False
    return True

def build_prod(args):
    if args.pull == None:
        args.pull = True
    if args.debug or args.dry_run:
        print('running docker build')
    if not hasattr(args, 'image') or not args.image:
        err('No image name was specified. Edit your Controlfile or specify with -i')
        exit(3)
    if not args.dry_run:
        for line in (json.loads(l.decode('utf-8').strip()) for l in docker.build(path='.',
                tag=args.image,
                nocache=args.no_cache,
                rm=args.no_rm,
                pull=args.pull,
                dockerfile=args.dockerfile)):
            print_formatted(line)
            if 'error' in line.keys():
                return False
    print('writing IMAGES.txt')
    if not args.dry_run:
        with open('IMAGES.txt', 'w') as f:
            f.write('{}\n'.format(args.image))
    return True

# Handle global defaults here
options = argparse.Namespace()
opts = vars(options)
opts['image'] = None
opts['dockerfile'] = 'Dockerfile'
opts['no_cache'] = False
opts['no_rm'] = True
opts['pull'] = None
opts['version'] = '1.3'

# Read in a Controlfile if one exists
if os.path.isfile('Controlfile'):
    with open('Controlfile', 'r') as f:
        try:
            vars(options).update(json.load(f))
        except json.decoder.JSONDecodeError as e:
            err('Malformed Controlfile. Not valid JSON: {}'.format(str(e)))
            exit(2)
else:
    # TODO: When, eventually, you have to do parsing to override defaults and you move to configparser, change this to print conditionally
    print('No Controlfile. Proceeding with defaults')

# If you set a value that has a default, set it up above, then you must
# reference that default here, otherwise it will be clobbered
parser = argparse.ArgumentParser(description='Control the building and running of images and containers')
parser.add_argument('-d', '--debug', action='store_true', help='print debug information helpful to developing the control script. This probably won\'t be useful to using the script, consider -v')
parser.add_argument('-f', '--force', action='store_true', help='be forceful in all things')
parser.add_argument('-n', '--dry-run', action='store_true', help='Pretend to execute actions, but only log that they happened')
parser.add_argument('-V', '--version', action='version', version='%(prog)s v{}'.format(options.version))
parser.set_defaults(func=build)
subparsers = parser.add_subparsers()

# TODO: add child parsers that handle the individual actions
build_parser = subparsers.add_parser('build', description='Build an image')
build_parser.add_argument('-i', '--image', default=options.image, help='override the tagged name of the image being built')
build_parser.add_argument('--dockerfile', default=options.dockerfile, help='override the dockerfile used to build the image')
build_parser.add_argument('--no-cache', action='store_true', help='do not use the cache')
build_parser.add_argument('--no-rm', action='store_false', help='do not remove any images, even on success')
build_parser.add_argument('--pull', action='store_const', const=True, help='pull the image from upstream')
build_parser.add_argument('--no-pull', action='store_const', const=False, dest='pull', help='do not pull newer versions of the base image')
build_parser.set_defaults(func=build)

buildprod_parser = subparsers.add_parser('build-prod', description='''Build a
        production image. This is the option used by Jenkins. No other options
        will be specified, so pick good defaults. Writes a file IMAGES.txt
        which is a newline delimited file of the images that should be pushed
        to the registry.''')
buildprod_parser.add_argument('-i', '--image', default=options.image, help='override the tagged name of the image being built')
buildprod_parser.add_argument('--no-cache', default=True, action='store_true', help='allow the build to use the cache')
buildprod_parser.add_argument('--no-pull', action='store_const', const=False, dest='pull', help='do not pull newer versions of the base image')
buildprod_parser.set_defaults(func=build_prod)
parser.parse_args(namespace=options)

if options.debug:
    print('options={}'.format(vars(options)))

# docker.Client doesn't raise an exception. They just crash the program. This
# is the most graceful way I can save this.
if os.path.exists('/var/run/docker.sock'):
    docker = docker.Client(base_url='unix://var/run/docker.sock')
else:
    err('docker daemon not started')
    exit(2)

ret = options.func(options)
if not ret:
    exit(1)
