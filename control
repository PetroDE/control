#!/usr/bin/env python3

# PetroDE Control script
#   It does stuff(TM)
#
# A script to build Docker images, compile code, run tests, be friendly to
# developers, enable local development, check in build configuration next to
# code, kiss babies, and be popular.
#
# We really don't expect much of it. /s
#
# Exit codes:
# 1 - Control operation failed, check output
# 2 - Something failed early (Docker daemon not started, malformed Controlfile)
# 3 - Operation pre-check failed

# Things that are needed:
#   - Clearly defined global options when ./control is run
#   - Clearly defined options when ./control build is run
#   - Override global defaults with Controlfile
#   - Override Controlfile settings with CLI arguments
#
# TODO: handle ^C without printing a stack trace, like normal people MOM!

import argparse
#import configparser
import docker
import json
import os
import re
import requests
import sys

from collections import namedtuple

def err(arg):
    print('{PROG}: {ARG}'.format(PROG=sys.argv[0], ARG=arg), file=sys.stderr)

Repository = namedtuple('Repository', ['domain', 'port', 'image', 'tag'])
repoMatcher = re.compile(r'(?:'
        r'(?P<domain>localhost|(?:[-_\w]+\.[-_\w]+)+|[-_\w]+(?=:))'
        r'(?::(?P<port>\d{1,5}))?'
        r'/)?'
        r'(?P<image>[-_./\w]+)'
        r'(?::(?P<tag>[-_.\w]+))?')
def getRepoFromString(str):
    '''This matches more than is valid, but not less than is valid. Notably,
        * Slash in the registry portion
        * Adjacent periods are accepted
    But, you had an invalid repo name if you hit either of those.'''
    m = repoMatcher.search(str)
    return Repository(domain=m.group('domain'),
            port=m.group('port'),
            image=m.group('image'),
            tag=m.group('tag'))

# TODO: finish
def isImageNewer(repo):
    r = requests.get(
            'https://{domain}:{port}/v2/{image}/manifests/{tag}'.format(domain=upstream.domain,
                port=upstream.port,
                image=upstream.image,
                tag=upstream.tag),
            verify='/etc/docker/certs.d/{domain}:{port}/ca.crt'.format(domain=upstream.domain,
                port=upstream.port))
    print(r.text)
    exit(-1)


def print_formatted(line):
    if options.debug:
        print('bytes: {}'.format(line))
    if len(line) == 1:
        print(list(line.values())[0].strip())
        return
    if 'error' in line.keys():
        print('\x1b[31m{}\x1b[0m'.format(line['error']))
    if 'id' in line.keys() and (not 'progressDetail' in line.keys() or not line['progressDetail']):
        print('{}: {}'.format(line['id'], line['status']))
        return

# TODO: DRY it up
def build(args):
    if args.debug or args.dry_run:
        print('running docker build')
    if not hasattr(args, 'image') or not args.image:
        err('No image name was specified. Edit your Controlfile or specify with -i')
        exit(3)
    if os.path.isfile(args.dockerfile):
        with open(args.dockerfile, 'r') as f:
            for line in f:
                if line.startswith('FROM'):
                    upstream = getRepoFromString(line.split()[1])
                    break
    if isImageNewer(upstream):
        pass
    if not args.dry_run:
        for line in (json.loads(l.decode('utf-8').strip()) for l in docker.build(path='.',
                tag=args.image,
                nocache=args.no_cache,
                rm=args.no_rm,
                pull=args.no_pull,
                dockerfile=args.dockerfile)):
            print_formatted(line)
            if 'error' in line.keys():
                return False
    return True

def build_prod(args):
    if args.debug or args.dry_run:
        print('running docker build')
    if not hasattr(args, 'image') or not args.image:
        err('No image name was specified. Edit your Controlfile or specify with -i')
        exit(3)
    if not args.dry_run:
        for line in (json.loads(l.decode('utf-8').strip()) for l in docker.build(path='.',
                tag=args.image,
                nocache=args.no_cache,
                rm=args.no_rm,
                pull=args.no_pull,
                dockerfile=args.dockerfile)):
            print_formatted(line)
            if 'error' in line.keys():
                return False
    print('writing IMAGES.txt')
    if not args.dry_run:
        with open('IMAGES.txt', 'w') as f:
            f.write('{}\n'.format(args.image))
    return True

# Handle global defaults here
options = argparse.Namespace()
opts = vars(options)
opts['image'] = None
opts['dockerfile'] = 'Dockerfile'
opts['no_cache'] = False
opts['no_rm'] = True
opts['no_pull'] = True
opts['version'] = '1.3'

# Read in a Controlfile if one exists
if os.path.isfile('Controlfile'):
    with open('Controlfile', 'r') as f:
        try:
            vars(options).update(json.load(f))
        except json.decoder.JSONDecodeError as e:
            err('Malformed Controlfile. Not valid JSON: {}'.format(str(e)))
            exit(2)
else:
    # TODO: When, eventually, you have to do parsing to override defaults and you move to configparser, change this to print conditionally
    print('No Controlfile. Proceeding with defaults')

# If you set a value that has a default, set it up above, then you must
# reference that default here, otherwise it will be clobbered
parser = argparse.ArgumentParser(description='Control the building and running of images and containers')
parser.add_argument('-d', '--debug', action='store_true', help='print debug information helpful to developing the control script. This probably won\'t be useful to using the script, consider -v')
parser.add_argument('-f', '--force', action='store_true', help='be forceful in all things')
parser.add_argument('-n', '--dry-run', action='store_true', help='Pretend to execute actions, but only log that they happened')
parser.add_argument('-V', '--version', action='version', version='%(prog)s v{}'.format(options.version))
parser.set_defaults(func=build)
subparsers = parser.add_subparsers()

# TODO: add child parsers that handle the individual actions
build_parser = subparsers.add_parser('build', description='Build an image')
build_parser.add_argument('-i', '--image', default=options.image, help='override the tagged name of the image being built')
build_parser.add_argument('--dockerfile', default=options.dockerfile, help='override the dockerfile used to build the image')
build_parser.add_argument('--no-cache', action='store_true', help='do not use the cache')
build_parser.add_argument('--no-rm', action='store_false', help='do not remove any images, even on success')
build_parser.add_argument('--no-pull', action='store_false', help='do not pull newer versions of the base image')
build_parser.set_defaults(func=build)

buildprod_parser = subparsers.add_parser('build-prod', description='''Build a production
        image. This is the option used by Jenkins. No other options will be
        specified, so pick good defaults. Writes a file IMAGES.txt which is a
        newline delimited file of the images that should be pushed to the
        registry.''')
buildprod_parser.add_argument('-i', '--image', default=options.image, help='override the tagged name of the image being built')
buildprod_parser.add_argument('--no-cache', default=True, action='store_true', help='allow the build to use the cache')
buildprod_parser.set_defaults(func=build_prod)
parser.parse_args(namespace=options)

if options.debug:
    print('options={}'.format(vars(options)))

# docker.Client doesn't raise an exception. They just crash the program. This
# is the most graceful way I can save this.
if os.path.exists('/var/run/docker.sock'):
    docker = docker.Client(base_url='unix://var/run/docker.sock')
else:
    err('docker daemon not started')
    exit(2)

ret = options.func(options)
if not ret:
    exit(1)
